<!--
title: Web Apps
order: 25
-->

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp">Web Apps</a> are a new approach to dramatically simplify .NET Wep App development 
    and provide the most productive development experience possible whilst maximizing reuse and component sharing. 
    They also open up a number of new use-cases for maintaining clean isolation between front-end and back-end development with
    front-end developers not needing any knowledge of C#/.NET to be able to develop UIs for high-performance .NET Web Apps. 
    Web Apps also make it easy to establish and share an approved suite of functionality amongst multiple websites all 
    consuming the same back-end systems and data stores.
</p>

<p>
    Web Apps leverages Templates to develop entire content-rich, data-driven websites without needing to write any C#, 
    compile projects or manually refresh pages - resulting in the easiest and fastest way to develop Web Apps in .NET!
</p>

<h4 id="ultimate-simplicity">Ultimate Simplicity</h4>

<p>
    Not having to write any C# code or perform any app builds dramatically reduces the cognitive overhead and conceptual knowledge 
    required for development where the only thing front-end Web developers need to know is <a href="/docs/syntax">Template's syntax</a> 
    and what <a href="/docs/filters-reference">filters are available</a> to call. 
    Because of Template's high-fidelity with JavaScript, developing a Website with Templates will be instantly familiar to JavaScript 
    devs despite calling and binding directly to .NET APIs behind the scenes.
</p>

<p>
    All complexity with C#, .NET, namespaces, references, .dlls, strong naming, packages, MVC, Razor, build tools, IDE environments, etc 
    has been eliminated leaving all Web Developers needing to do is run a cross-platform 
    <a href="https://github.com/NetCoreWebApps/Web">web/app.dll</a> .NET Core 2.0 executable and configure a simple 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/bare/web.settings">web.settings</a>    
    text file to specify which website folder to use, which ServiceStack features to enable, which db or redis providers to connect to, etc.
    Not needing to build also greatly simplifies deployments where multiple websites can be deployed with a 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.deploy.apps.sh">single rsync</a> or xcopy command or 
    if deploying your App in a Docker Container, you just need to 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/Dockerfile">copy your website files</a>, or just the <em>web.settings</em>    
    if you're using an S3 or Azure Virtual File System.
</p>

<h4>Rapid Development Workflow</h4>

<p>
    The iterative development experience is also unparalleled for a .NET App, no compilation is required so you can just leave
    the <em>web/app.dll</em> running whilst you add the template <em>.html</em> files needed to build your App and thanks
    to the built-in <a href="/docs/hot-reloading">Hot Reloading</a> support, pages will refresh automatically as you save.
    You'll just need to do a full page refresh when modifying external .css/.js files to bypass the browser cache and
    you'll need to restart <em>web/app.dll</em> to pick up any changes to your <em>web.settings</em> or added any 
    .dlls to your <em>/plugins</em> folder.
</p>

<h2>Getting Started</h2>

<p>
    The easiest way to get started is to create a new <a href="https://github.com/NetCoreTemplates/templates-webapp">templates-webapp</a> project:
</p>

<pre class="sh">
<code>    $ npm install -g @servicestack/cli

    $ dotnet-new templates-webapp ProjectName
</code></pre>

<p>
    This will create a new project that contains 2 folders, <a href="https://github.com/NetCoreTemplates/templates-webapp/tree/master/app">/app</a> contains all source code and 
    assets for your Web App and <a href="https://github.com/NetCoreTemplates/templates-webapp/tree/master/web">/web</a> contains a copy of the WebApp 
    binaries from <a href="https://github.com/NetCoreWebApps/Web">ServiceStack/WebApp</a>. 
</p>
    
<p>
    The project can be run from Windows, OSX and Linux. To run in VS Code type <em>Ctrl+Shift+B</em> to run the configured build task, 
    otherwise you can run from the command-line with:
</p>

<pre class="sh"><code>dotnet web/app.dll ../app/web.settings</code></pre>

<p>
    Once running you can view your App on <em>http://localhost:5000/</em> which you can keep running whilst developing your app
    which will reload the page you're currently viewing on each file save using the built-in <a href="/docs/hot-reloading">Hot Reloading</a>.
</p>

<p>
    <em>/app</em> is an example of a single Web App, you can have multiple Web Apps in different folders and run any of them with:         
</p>

<pre class="sh"><code>dotnet web/app.dll ../&lt;app name&gt;/web.settings</code></pre>

<h4>Cloud Apps Starter Projects</h4>

<p>
    If you intend to deploy your Web App on AWS or Azure you may prefer to start with one of the example 
    Cloud Apps below which come pre-configured with deployment scripts for deploying with Travis CI and Docker:
</p>

<ul>
    <li><a href="https://github.com/NetCoreWebApps/Rockwind.Aws">Rockwind.Aws</a></li>
    <li><a href="https://github.com/NetCoreWebApps/Rockwind.Azure">Rockwind.Azure</a></li>
</ul>

<h2>Example Web Apps</h2>

<p>
    We've developed a number of Web Apps to illustrate the various features available and to showcase the different kind of Web Apps
    that can easily be developed. The source code for each app is available either individually from 
    <a href="https://github.com/NetCoreWebApps">github.com/NetCoreWebApps</a> or all combined in the same repo at
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">NetCoreWebApps/WebApp/apps</a>. 
    Each app runs the same unmodified <a href="https://github.com/NetCoreWebApps/Web">Web App Binary</a> that's also used in the 
    WebAppStarter project above. 
</p>

<h4>Running Web Apps locally</h4>

<p>
    Each of these apps can be run locally by cloning <a href="https://github.com/NetCoreWebApps/WebApp">NetCoreWebApps/WebApp</a>
    and running the start.bat scripts in the <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">/apps</a> folder.
    If you want to use your local RDBMS you can use
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/northwind-data">/support/northwind-data</a> to quickly
    populate it with the Northwind database and 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/copy-files">/support/copy-files</a> to populate your own
    S3 Bucket or Azure Blob Container with the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> Web App's files. 
    As each app runs on <em>http://localhost:5000</em> you'll need to do a hard refresh with <em>Ctrl+Shift+F5</em> after
    launching each App to tell the browser to ignore the cached .css and .js from the previous App.
</p>

<h3>Web App Starter</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebAppStarter">/WebAppStarter</a> - 
    <a href="http://bare.web-app.io">bare.web-app.io</a>
</div>

<p>
    The Getting Started project contains a copy of the <a href="http://bare.web-app.io">bare.web-app.io</a> project below 
    which is representative of a typical Company splash Website:
</p>

<a href="http://bare.web-app.io"><img src="/assets/img/screenshots/bare.png" alt="Bare WebApp screenshot"></a>

<p>
    The benefits over using a static website is improved maintenance
    as you can extract and use its common <a href="https://github.com/NetCoreWebApps/WebAppStarter/blob/master/app/_layout.html">_layout.html</a>
    instead of having it duplicated in each page. 
    The <a href="https://github.com/NetCoreWebApps/WebAppStarter/blob/master/app/menu.html">menu.html</a> partial also makes menu items
    easier to maintain by just adding an entry in the JavaScript object literal. The dynamic menu also takes care of highlighting the active menu item.
</p>

<pre class="cs"><code>{{ 'examples/webapps-menu.html' | includeFile }}</code></pre>

<h4>Ideal for Web Designers and Content Authors</h4>

<p>
    The other primary benefit is that this is an example of a website that can be maintained by employees who don't have any
    programming experience as Templates in their basic form are intuitive and approachable to non-developers, e.g: 
    The title of each page is maintained as metadata HTML comments:
</p>

<pre class="cs"><code>&lt;!--
title: About Us
--&gt;
</code></pre>

<p>
    Template's syntax is also the ideal way to convey variable substitution, e.g: <em>&lt;title&gt;{{ pass: title }}&lt;/title&gt;</em> 
    and even embedding a partial reads like english <em>{{ pass: 'menu' | partial }}</em> which is both intuitive and works well 
    with GUI HTML designers.
</p>

<h5><a href="https://github.com/NetCoreWebApps/WebAppStarter/blob/master/app/web.settings">web.settings</a></h5>

<p>
    Below is the <em>web.settings</em> for a Basic App, with <b>contentRoot</b> being the only setting required as the
    rest can be inferred but including the other relevant settings is both more descriptive to other developers as well
    making it easier to 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.deploy.apps.sh">use tools like sed</a> or 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.bare.ps1">powershell to replace them</a>    
    during deployment.
</p>

<pre class="settings"><code>debug true
name Bare Web App
port 5000
contentRoot ~/../bare
webRoot ~/../bare</code></pre>

<blockquote>
    <em>debug true</em> controls the level of internal diagnostics available and whether or not <a href="/docs/hot-reloading">Hot Reloading</a> is enabled.
</blockquote>

<h3>Redis HTML</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/redis-html">/redis-html</a> - 
    <a href="http://redis-html.web-app.io">redis-html.web-app.io</a>
</div>

<p>
    For the Redis Browser Web App, we wanted to implement an App that was an ideal candidate for a Single Page App but constrain ourselves
    to do all HTML rendering on the server and have each interaction request a full-page reload to see how a traditional server-generated
    Web App feels like with the performance of .NET Core 2.0 and Templates. We're pleasantly surprised with the result as when 
    the App is run locally the responsiveness is effectively indistinguishable from an Ajax App. When hosted on the Internet 
    there is a sub-second delay which causes a noticeable flicker but it still retains a pleasant UX that's faster than most websites.
</p>

<p>
    The benefits of a traditional website is that it doesn't break the web where the back button and deep linking work without effort 
    and you get to avoid the complexity train of adopting a premier JavaScript SPA Framework's configuration, dependencies, workflow 
    and build system which has become overkill for small projects.
</p>

<a href="http://redis-html.web-app.io"><img src="/assets/img/screenshots/redis-html.png" alt="Redis HTML WebApp Screenshot"></a>

<p>
    We've had a sordid history developing Redis UI's which we're built using the popular JavaScript frameworks that appeared 
    dominant at the time but have since seen their ecosystem decline, starting with the
    <a href="http://redisadminui.servicestack.net/">Redis Admin UI</a> (<a href="https://github.com/ServiceStackApps/RedisAdminUI">src</a>) 
    built using 
    <a href="https://github.com/google/closure-library">Google's Closure Library</a> that as it works different to everything else 
    needed a complete rewrite when creating <a href="http://redisreact.servicestack.net">redisreact.servicestack.net</a>
    (<a href="https://github.com/ServiceStackApps/RedisReact">src</a>) using the hot new React framework, unfortunately it uses React's old 
    deprecated ES5 syntax and Reflux which is sufficiently different from our current recommended 
    <a href="http://docs.servicestack.net/templates-single-page-apps">TypeScript + React + Redux + WebPack</a> JavaScript SPA Stack,
    that is going to require a significant refactor to adopt our preferred SPA tech stack.
</p>

<h5>Beautiful, succinct, declarative code</h5>

<p>
    The nice thing about generating HTML is that it's the one true constant in Web development that will always be there.
    The entire functionality for the Redis Web App is contained in a single
    <a href="https://github.com/NetCoreWebApps/RedisHtml/blob/master/app/index.html">/RedisHtml/app/index.html</a> which includes
    all Template and JavaScript Source Code in <b>&lt; 200 lines</b> which also includes all as server logic as it doesn't rely on any 
    back-end Services and just uses the <a href="/docs/redis-filters">Redis Filters</a> to interface with Redis directly.
    The <a href="https://github.com/NetCoreWebApps/RedisHtml/blob/master/app/index.html">source code</a> also serves as a good 
    demonstration of the declarative coding style that Templates encourages that in addition to being highly-readable requires orders 
    of magnitude less code than our previous Redis JavaScript SPA's with a comparable feature-set.
</p>

<p>
    Having a much smaller code-base makes it much easier to maintain and enhance whilst being less susceptible to becoming obsolete 
    by the next new JavaScript framework as it would only require rewriting 75 lines of JavaScript instead of the complete rewrite 
    that would be required to convert the existing JavaScript Apps to a use different JavaScript fx.
</p>

<h5><a href="https://github.com/NetCoreWebApps/RedisHtml/blob/master/app/web.settings">web.settings</a></h5>

<p>
    The <em>web.settings</em> for Redis is similar to Web App Starter above except it adds a <em>redis.connection</em>
    to configure a <a href="https://github.com/ServiceStack/ServiceStack.Redis#redismanagerpool">RedisManagerPool</a> at the
    <a href="https://github.com/ServiceStack/ServiceStack.Redis#redis-connection-strings">connection string</a> provided
    as well as <a href="/docs/redis-filters">Redis Filters</a> to give Templates access to the Redis instance.
</p>

<pre class="settings"><code>debug true
name Redis Web App
port 5000
contentRoot ~/../redis-html
webRoot ~/../redis-html
redis.connection localhost:6379</code></pre>

<h3>Redis Vue</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/redis">/redis</a> - 
    <a href="http://redis.web-app.io">redis.web-app.io</a>
</div>

<p>
    Whilst the above server-generated HTML Redis UI shows how you can easily develop traditional Web Apps using Templates, we've also
    rewritten the Redis UI as a Single Page App which is the more suitable choice for an App like this as it provides a more
    optimal and responsive UX by only loading the HTML page once on Startup then utilizes Ajax to only download and update 
    the incremental parts of the App's UI that needs changing.
</p>

<p>
    Instead of using jQuery and server-side HTML this version has been rewritten to use <a href="https://vuejs.org">Vue</a>
    where the UI has been extracted into isolated Vue components utilizing 
    <a href="https://vuejs.org/v2/guide/components.html#X-Templates">Vue X-Templates</a> to render the App on the client where 
    all Redis Vue's functionality is contained within the
    <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/index.html">Redis/app/index.html</a> page.     
</p>

<a href="http://redis.web-app.io"><img src="/assets/img/screenshots/redis.png" alt="Redis Vue WebApp Screenshot"></a>

<h4>Simple Vue App</h4>

<p>
    Templates also provides a great development experience for Single Page Apps which for the most part gets out of your way letting you 
    develop the Single Page App as if it were a static <em>.html</em> file, but also benefits from the flexibility of a 
    dynamic web page when needed. 
</p>
<p>
    The containing <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/_layout.html">_layout.html</a>
    page can be separated from the <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/index.html">index.html</a> page 
    that contains the App's functionality, where it's able to extract the <em>title</em> of the page and embed it in the 
    HTML <em>&lt;head/&gt;</em> as well as embed the page's <em>&lt;script /&gt;</em> in its optimal location at the bottom of the 
    HTML <em>&lt;body/&gt;</em>, after the page's blocking script dependencies:
</p>

{{ 'gfm/web-apps/07.md' | githubMarkdown }}

<p>
    Redis Vue avoids the complexity of adopting a npm build system by refrencing Vue libraries as a simple script include:
</p>

<pre class="html"><code>&lt;script src="../assets/js/vue{{ pass: '.min' | if(!debug) }}.js"&gt;</script></code></pre>

<p>
    Where it uses the more verbose and developer-friendly 
    <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/assets/js/vue.js">vue.js</a>
    during development whilst using the production optimized 
    <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/assets/js/vue.min.js">vue.min.js</a>
    for deployments. So despite avoiding the complexity tax of an npm-based build system it still gets some of its benefits
    like conditional deployments and effortless <a href="/docs/hot-reloading">hot reloading</a>.
</p>

<h4>Server Templates</h4>

<p>
    Whilst most of <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/index.html">index.html</a> is a static Vue 
    app, templates is leveraged to generate the body of the <em>&lt;redis-info/&gt;</em> Component on the initial home page render:
</p>

{{ 'gfm/web-apps/08.md' | githubMarkdown }}

<p>
    This technique increases the time to first paint by being able to render the initial Vue page without waiting for an Ajax call response
    whilst benefiting from improved SEO from server-generated HTML.
</p>

<h4>Server Handling</h4>

<p>
    Another area Templates is used is to handle the HTTP POST where it calls the <em>redisChangeConnection</em> filter to change 
    the current Redis connection before rendering the 
    <a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/connection-info.html">connection-info.html</a> partial with the 
    current connection info:
</p>

{{ 'gfm/web-apps/09.md' | githubMarkdown }}

<h4>Vue Ajax Server APIs</h4>

<p>
    All other Server functionality is invoked by Vue using Ajax to call one of the Ajax APIs below implemented as 
    <a href="/docs/api-pages">API Pages</a>:
</p>

<h5><a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/api/search.html">search.html</a></h5>

<p>
    Called when searching for Redis keys where the query is forwarded to the <em>redisSearchKeys</em> filter:
</p>

{{ 'gfm/web-apps/10.md' | githubMarkdown }}

<h5><a href="https://github.com/NetCoreWebApps/Redis/blob/master/app/api/call.html">call.html</a></h5>

<p>
    Called to execute an arbitrary Redis command on the connected instance, with the response from Redis is returned as a 
    plain-text HTTP Response:
</p>

{{ 'gfm/web-apps/11.md' | githubMarkdown }}

<p>
    The benefits of using API Pages instead of a normal C# Service is being able to retain Web App's productive development workflow
    where the entire Redis Vue App is built without requiring any compilation.
</p>

<h3>Deep linking and full page reloads</h3>

<p>
    The Redis Vue Single Page App also takes advantage of HTML5's <em>history.pushState</em> API to enable deep-linking and back-button
    support where most UI state changes is captured on the query string and used to initialize the Vue state on page navigation or
    full-page reloads where it proivdes transparent navigation and back-button support that functions like a traditional Web App but with 
    the instant performance of a Single Page App.
</p>

<h3>Rockwind</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/Rockwind">/rockwind</a> - 
    <a href="http://rockwind-sqlite.web-app.io">rockwind-sqlite.web-app.io</a>
</div>

<p>
    The Rockwind website shows an example of combining multiple websites in a single Web App - a 
    <b><em>Rock</em>stars</b> Content Website and a dynamic data-driven UI for the <b>North<em>wind</em></b> database which can 
    run against either SQL Server, MySql or SQLite database using just configuration. It also includes 
    <a href="/docs/api-pages">API Pages</a> examples for rapidly developing Web APIs.
</p>

<h4>Rockstars</h4>

<p>
    <a href="https://github.com/NetCoreWebApps/Rockwind/tree/master/app/rockstars">/rockstars</a> is an 
    example of a Content Website that itself maintains multiple sub sections with their own layouts -
    <a href="https://github.com/NetCoreWebApps/Rockwind/tree/master/app/rockstars/alive">/rockstars/alive</a> 
    for living Rockstars and 
    <a href="https://github.com/NetCoreWebApps/Rockwind/tree/master/app/rockstars/dead">/rockstars/dead</a>
    for the ones that have died. Each Rockstar maintains their own encapsulated
    <a href="https://github.com/NetCoreWebApps/Rockwind/tree/master/app/rockstars/alive/grohl">mix of HTML, markdown content and splash image</a>
    that intuitively uses the closest <em>_layout.html</em>, <em>content.md</em> and <em>splash.jpg</em> from the page they're
    referenced from. This approach makes it easy to move entire sub sections over by just moving a folder and it will automatically
    use the relevant layout and partials of its parent.
</p>

<a href="http://rockwind-sqlite.web-app.io"><img src="/assets/img/screenshots/rockwind.png" alt="Rockwind WebApp screenshot"></a>

<h4>Northwind</h4>

<p>
    <a href="https://github.com/NetCoreWebApps/Rockwind/tree/master/app/northwind">/northwind</a> is an example of 
    a dynamic UI for a database containing a 
    <a href="http://rockwind-sqlite.web-app.io/northwind/customers?country=Germany">form to filter results</a>, multi-nested 
    <a href="http://rockwind-sqlite.web-app.io/northwind/customer?id=ALFKI">detail pages</a> and 
    <a href="http://rockwind-sqlite.web-app.io/northwind/order?id=10643">deep-linking</a> for quickly navigating between 
    referenced data. Templates is also a great solution for rapidly developing Web APIs where the 
    <a href="https://github.com/NetCoreWebApps/Rockwind/blob/master/app/api/customers.html">/api/customers.html</a>
    API Page below:
</p>

{{ 'gfm/api-pages/02.md' | githubMarkdown }}

<p>
    Is all the code needed to generate the following API endpoints:
</p>

<style>
    th:first-child {
        text-align: right;
    }
</style>

<table class="table table-striped">
    <tr class="bg-success">
        <td colspan="2" style="text-align:center;color:#fff;font-size:1.5rem">/customers API</td>
    </tr>
    <tr>
        <th>All Customers</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers">/api/customers</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv">/api/customers.csv</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html">/api/customers.html</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?format=html">/api/customers?format=html</a></div>
            <div style="margin:5px 0 0 0;color:#888;font-size:13px"><b>Accept</b> HTTP Header also supported</div>
        </td>
    </tr>
    <tr>
        <th>Alfreds Futterkiste Details</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI">/api/customers/ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI.csv">/api/customers/ALFKI.csv</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI.html">/api/customers/ALFKI.html</a></div>
        </td>
    </tr>
    <tr>
        <th>As List</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?id=ALFKI">/api/customers?id=ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?id=ALFKI">/api/customers.csv?id=ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?id=ALFKI">/api/customers.html?id=ALFKI</a></div>
        </td>
    </tr>
    <tr>
        <th>Customers in Germany</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?country=Germany">/api/customers?country=Germany</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?country=Germany">/api/customers.csv?country=Germany</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?country=Germany">/api/customers.html?country=Germany</a></div>
        </td>
    </tr>
    <tr>
        <th>Customers in London</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?city=London">/api/customers?city=London</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?city=London">/api/customers.csv?city=London</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?city=London">/api/customers.html?city=London</a></div>
        </td>
    </tr>    
    <tr>
        <th>Combination Query</th>
        <td>
            <a href="http://rockwind-sqlite.web-app.io/api/customers?city=London&amp;country=UK&amp;limit=3">/api/customers?city=London&amp;country=UK&amp;limit=3</a>
        </td>
    </tr>
</table>

<h4>Multi platform configurations</h4>

<p>
    In addition to being a .NET Core 2.0 App that runs flawlessly cross-platform on Windows, Linux and OSX, Web Apps can also support 
    multiple RDBMS's and <a href="http://docs.servicestack.net/virtual-file-system">Virtual File Systems</a> using just configuration.
</p>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.sqlite.settings">web.sqlite.settings</a></h5>

<p>
    SQLite uses a file system database letting you bundle your database with your App. So we can share the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">northwind.sqlite</a> database across multiple Apps, 
    the <em>contentRoot</em> is set to the <em>/apps</em> directory which can only be accessed by your App, whilst
    the <em>webRoot</em> is configured to use the Web Apps folder that hosts all the publicly accessible files of your App.
</p>

<pre class="settings"><code>debug true
name Rockwind SQLite Web App
port 5000
contentRoot ~/..
webRoot ~/../rockwind
db sqlite
db.connection ~/northwind.sqlite</code></pre>

<p>
    To run the Rockwind app using the <em>northwind.sqlite</em> database, run the command below on Windows, Linux or OSX: 
</p>

<pre class="sh"><code>dotnet web/app.dll ../rockwind/web.sqlite.settings</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.sqlserver.settings">web.sqlserver.settings</a></h5>

<p>
    To switch to use the Northwind database in SQL Server we just need to update the configuration to point to a SQL Server database 
    instance. Since the App no longer need access to the <em>northwind.sqlite</em> database, the <em>contentRoot</em> can be reverted 
    back to the Web Apps folder:
</p>

<pre class="settings"><code>debug true
name Rockwind SQL Server Web App
port 5000
contentRoot ~/../rockwind
webRoot ~/../rockwind
db sqlserver
db.connection Server=localhost;Database=northwind;User Id=test;Password=test;</code></pre>

<p>
    The <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/northwind-data">/support/northwind-data</a>
    project lets you quickly try out Rockwind against your local RDBMS by populating it with a copy of the Northwind database
    using the same <em>sqlserver</em> identifier and connection string from the App, e.g:
</p>

<pre class="sh"><code>dotnet run sqlserver "Server=localhost;Database=northwind;User Id=test;Password=test;"</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.mysql.settings">web.mysql.settings</a></h5>

<p>
    You can run against a MySql database in the same way as SQL Server above but using a MySql db connection string:
</p>

<pre class="settings"><code>debug true
name Rockwind MySql Web App
port 5000
contentRoot ~/../rockwind
webRoot ~/../rockwind
db mysql
db.connection Server=localhost;Database=northwind;UID=root;Password=test</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.azure.settings">web.azure.settings</a></h5>

<p>
    The example Azure configuration is also configured to use a different Virtual File System where instead of sourcing 
    Web App files from the filesystem they're sourced from an 
    <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-dotnet-how-to-use-blobs">Azure Blob Container</a>.
    In this case we're not using any files from the App so we don't need to set a <em>contentRoot</em> or <em>webRoot</em> path.
    This also means that for deployment we're just deploying the <a href="https://github.com/NetCoreWebApps/Web">WebApp</a>
    binary with just this <em>web.settings</em> since both the Web App files and database are sourced remotely.
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name Azure Blob SQL Server Web App
bind *
port 5000
db sqlserver
db.connection $AZURE_SQL_CONNECTION_STRING
files azure
files.config {ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind-fs}

# Reduces a Blob Storage API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<p>
    The <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/copy-files">/support/copy-files</a>
    project lets you run Rockwind against your own Azure Blob Container by populating it with a copy of the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind">/rockwind</a> App's files using 
    the same configuration above:
</p>

<pre class="sh"><code>dotnet run azure "{ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind}"</code></pre>

<h4>Multi-RDBMS SQL</h4>

<p>
    As Templates is unable to use a Typed ORM like <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a>
    to hide the nuances of each database, we need to be a bit more diligent in Templates to use parameterized SQL that works across 
    multiple databases by using the 
    <a href="/docs/filters-reference?nameContains=sql&amp;tab=db-filters"><em>sql*</em> DB Filters</a> to avoid using RDBMS-specific
    SQL syntax. The 
    <a href="https://github.com/NetCoreWebApps/Rockwind/blob/master/app/northwind/customer.html">/northwind/customer.html</a>
    contains a good example containing a number of things to watch out for:
</p>

{{ 'gfm/web-apps/01.md' | githubMarkdown }}

<p>
    Use <em>sqlConcat</em> to concatenate strings using the RDBMS-specific SQL for the configured database. Likewise
    <em>sqlCurrency</em> utilizes RDBMS-specific SQL functions to return monetary values in a currency format, whilst 
    <em>sqlQuote</em> is used for quoting tables named after a reserved word.
</p>

<blockquote>
    Of course if you don't intend on supporting multiple RDBMS's, you can ignore this and use RDBMS-specific syntax.    
</blockquote>

<h3>Rockwind VFS</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> - 
    <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a>
</div>

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> is a clone of
    the Rockwind Web App with 3 differences: It uses the <em>resolveAsset</em> filter for each <em>.js</em>, <em>.css</em> and 
    <em>image</em> web asset so that it's able to generate external URLs directly to the S3 Bucket, Azure Blob Container or CDN 
    hosting a copy of your files to both reduce the load on your Web App and maximize the responsiveness to the end user.    
</p>

<p>
    To maximize responsiveness when using remote storage, all 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind-vfs/rockstars/alive/grohl/index.html">embedded files utilize caching</a>:
</p>

<pre class="tpl"><code>{{ pass: "content.md" | includeFileWithCache | markdown }}</code></pre>

<p>
    The other difference is that each table and column has been quoted in "double-quotes" so that it works in PostgreSQL which
    otherwise treats unquoted symbols as lowercase. This version of Rockwind also works with SQL Server and SQLite as they also 
    support <em>"Table"</em> quotes but not MySql which uses <em>`BackTicks`</em> or <em>[SquareBrackets]</em>. It's therefore
    infeasible to develop Apps that support both PostgreSQL and MySql unless you're willing to use all <b>lowercase</b>, 
    <b>snake_case</b> or the <em>sqlQuote</em> filter for every table and column.
</p>

<a href="http://rockwind-aws.web-app.io"><img src="/assets/img/screenshots/rockwind.png" alt="Rockwind VFS WebApp screenshot"></a>

<h4>resolveAsset</h4>

<p>
    If using a remote file storage like AWS S3 or Azure Blob Storage it's a good idea to use the <em>resolveAsset</em> filter 
    for each external file reference. By default it returns the same path it was called with so it will continue to work locally 
    but then ServiceStack effectively becomes a proxy where it has to call the remote Storage Service for each requested download.
</p>

{{ 'gfm/web-apps/02.md' | githubMarkdown }}

<p>
    ServiceStack asynchronously writes each file to the Response Stream with the last <em>Last-Modified</em> HTTP Header to 
    enable browser caching so it's still a workable solution but for optimal performance you can specify an <em>args.assetsBase</em>
    in your web.settings to populate the assetsBase <em>TemplateContext</em> Argument the <em>resolveAsset</em> filter uses to generate
    an external URL reference to the file on the remote storage service, reducing the load and improving the performance of your App, 
    especially if it's configured to use a CDN. 
</p>

<h4 id="pure-cloud-apps">Pure Cloud Apps</h4>

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Aws/blob/master/app/web.settings">Rockwind.Aws/web.settings</a></h5>

<p>
    The AWS settings shows an example of this where every external resource 
    <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a> has been replaced with a direct reference to the 
    asset on the S3 bucket:
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name AWS S3 PostgreSQL Web App
bind *
port 5000
db postgres
db.connection $AWS_RDS_POSTGRES
files s3
files.config {AccessKey:$AWS_ACCESS_KEY,SecretKey:$AWS_SECRET_KEY,Region:us-east-1,Bucket:rockwind}
args.assetsBase http://s3-postgresql.s3-website-us-east-1.amazonaws.com/

# Reduces an S3 API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<p>
    With all files being sourced from S3 and the App configured to use AWS RDS PostgreSQL, the AWS settings is an example of 
    a <b>Pure Cloud App</b> where the entire App is hosted on managed cloud services that's decoupled from the .NET Core 2.0 binary 
    that runs it that for the most part won't require redeploying the Web App binary unless making configuration changes or 
    upgrading the <em>web/app.dll</em> as any App changes can just be uploaded straight to S3 which changes reflected within the
    <em>checkForModifiedPagesAfterSecs</em> setting, which tells the Web App how long to wait before checking for file changes
    whilst <em>defaultFileCacheExpirySecs</em> specifies how long to cache files like <em>content.md</em> for.
</p>

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Aws/blob/master/Dockerfile">DockerFile</a></h5>

<p>
    Deployments are also greatly simplified as all that's needed is to deploy the WebApp binary and web.settings of your Cloud App,
    e.g. here's the DockerFile for <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a> - deployed to AWS ECS 
    using the deployment scripts in <a href="https://github.com/NetCoreWebApps/Rockwind.Aws">Rockwind.Aws</a> and following our 
    <a href="http://docs.servicestack.net/deploy-netcore-docker-aws-ecs">.NET Core Docker Deployment Guideline</a>:
</p>

{{ 'gfm/web-apps/03.md' | githubMarkdown }}

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Azure/blob/master/app/web.settings">Rockwind.Azure/web.settings</a></h5>

<p>
    We can also create Azure Cloud Apps in the same we've done for AWS above, which runs the same 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a>
    Web App but using an Azure hosted SQL Server database and its files hosted on Azure Blob Storage:
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name Azure Blob SQL Server Web App
bind *
port 5000
db sqlserver
db.connection $AZURE_SQL_CONNECTION_STRING
files azure
files.config {ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind}
args.assetsBase https://servicestack.blob.core.windows.net/rockwind/

# Reduces an S3 API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<h3>Plugins</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/plugins">/plugins</a> - 
    <a href="http://plugins.web-app.io">plugins.web-app.io</a>
</div>

<p>
    Up till now the Apps above only have only used functionality built into ServiceStack, to enable even greater functionality
    but still retain all the benefits of developing Web Apps you can drop <b>.dll</b> with custom functionality into your 
    Web App's <em>/plugins</em> folder. The plugins support in Web Apps is as friction-less as we could make it, there's no 
    configuration to maintain or special interfaces to implement, you're able to drop your <b>existing implementation .dll's</b> 
    as-is into the App's `/plugins` folder.
</p>

<p>
    Plugins allow "no touch" sharing of 
    <a href="http://docs.servicestack.net/plugins">ServiceStack Plugins</a>, 
    <a href="http://docs.servicestack.net/create-your-first-webservice">Services</a>, 
    <a href="http://templates.servicestack.net/docs/filters">Template Filters</a>
    <a href="http://templates.servicestack.net/docs/code-pages">Template Code Pages</a>,
    <a href="http://docs.servicestack.net/validation">Validators</a>, etc.
    contained within <b>.dll's</b> or <b>.exe's</b> dropped in a Web App's 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/plugins/plugins">/plugins</a> folder which are auto-registered 
    on startup. The source code for all plugins used in this App were built from the .NET Core 2.0 projects in the
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/example-plugins">/example-plugins</a> folder. The 
    <a href="http://plugins.web-app.io">plugins.web-app.io</a> Web App below walks through examples of using Custom Filters, 
    Services and Validators:
</p>

<a href="http://plugins.web-app.io"><img src="/assets/img/screenshots/plugins.png" alt="Plugins WebApp screenshot"></a>

<h4>Registering ServiceStack Plugins</h4>

<p>
    <a href="http://docs.servicestack.net/plugins">ServiceStack Plugins</a> can be added to your App by 
    listing it's Type Name in the <em>features</em> config entry in 
    <a href="https://github.com/NetCoreWebApps/Plugins/tree/master/app/web.settings">web.settings</a>:
</p>

<pre class="settings"><code>debug true
name Web App Plugins
port 5000
contentRoot ~/../plugins
webRoot ~/../plugins
features CustomPlugin, OpenApiFeature, PostmanFeature, CorsFeature, ValidationFeature
CustomPlugin { ShowProcessLinks: true }
ValidationFeature { ScanAppHostAssemblies: true }
</code></pre>

<p>
    All plugins listed in <em>features</em> will be added to your Web App's AppHost in the order they're specified. 
    They can further customized by adding a separate config entry with the Plugin Name and a JavaScript Object literal to 
    populate the Plugin at registration, e.g the config above is equivalent to:
</p>

{{ 'gfm/web-apps/04.md' | githubMarkdown }}

<h4>Custom Plugin</h4>

<p>
    In this case it tells our <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/ServerInfo/CustomPlugin.cs">CustomPlugin</a>
    from <b>/plugins/ServerInfo.dll</b> to also show Process Links in its
    <a href="http://plugins.web-app.io/metadata">/metadata</a> Page:
</p>

{{ 'gfm/web-apps/05.md' | githubMarkdown }}

<p>
    Where as it was first registered in the list will appear before any links registered by other plugins:
</p>

<img src="http://plugins.web-app.io/assets/img/metadata-screenshot.png" alt="Metadata screenshot">

<h4>Built-in Plugins</h4>

<p>
    It also tells the <em>ValidationFeature</em> to scan all Service Assemblies for Validators and to automatically register them
    which is how ServiceStack was able to find the
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/ServerInfo/ContactServices.cs">ContactValidator</a>
    used to validate the <em>StoreContact</em> request.
</p>

<p>
    Other optional plugins registered in this Web App is the metadata Services required for 
    <a href="http://docs.servicestack.net/openapi">Open API</a>, 
    <a href="http://docs.servicestack.net/postman">Postman</a> as well as
    <a href="http://docs.servicestack.net/corsfeature">support for CORS</a>.
    You can check the <a href="/metadata/debug">/metadata/debug</a> Template for all Plugins loaded in your AppHost.
</p>

<h3 id="netcore-extensibility">.NET Extensibility</h3>

<p>
    Plugins can also implement .NET Core's <em>IStartup</em> to be able to register any required dependencies without any coupling to any Custom AppHost.
</p>

<p>
    To simplify configuration you can use the `plugins/*` wildcard in 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/plugins2/web.settings">web.settings</a>
    at the end of an ordered plugin list to register all remaining Plugins it finds in the apps `/plugins` folder:
</p>


<pre class="settings"><code>features OpenApiFeature, PostmanFeature, CorsFeature, ValidationFeature, plugins/*
CustomPlugin { ShowProcessLinks: true }
</code></pre>

<p>
    Each plugin registered can continue to be furthered configured by specifying its name and a JavaScript object literal as seen above.
</p>

<p>
    The <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/plugins2">/plugins2</a>  App shows an example of this with the 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/ServerInfo/StartupPlugin.cs">StartupPlugin</a>
    registering a <em>StartupDep</em> dependency which is used by its <em>StartupServices</em> at runtime:
</p>

{{ 'gfm/web-apps/12.md' | githubMarkdown }}

<h3>ServiceStack Ecosystem</h3>

<p>
    All Services loaded by plugins continue to benefit from ServiceStack's rich metadata services, including being listed 
    in the <a href="/metadata">/metadata</a> page, being able to explore and interact with Services using 
    <a href="/swagger-ui/">/swagger-ui/</a> as well as being able to generate Typed APIs for the most popular
    <a href="http://docs.servicestack.net/add-servicestack-reference">Mobile, Web and Desktop platforms</a>.
</p>

<h3>Chat</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app">/chat</a> - 
    <a href="http://chat.web-app.io">chat.web-app.io</a>
</div>

<p>
    <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app">/chat</a> is an example of the ultimate form 
    of extensibility where instead of just being able to add Services, Filters and Plugins, etc. You can add your entire 
    <em>AppHost</em> which Web Apps will use instead of its own. This vastly expands the use-cases that can be built with 
    Web Apps as it gives you complete fine-grained control over how your App is configured.
</p>

<a href="http://chat.web-app.io"><img src="/assets/img/screenshots/chat.png" alt="Chat WebApp screenshot"></a>

<h4>Develop back-end using .NET IDE's</h4>

<p>
    For <a href="http://chat.web-app.io">chat.web-app.io</a> we've taken a copy of the existing .NET Core 2.0 
    <a href="https://github.com/NetCoreApps/Chat">Chat App</a> and moved its C# code to
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/example-plugins/Chat">/example-plugins/Chat</a>
    and its files to <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app">/apps/chat</a> 
    where it can be developed like any other Web App except it utilizes the Chat AppHost and implementation in the 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/Chat/Program.cs">SelfHost Chat App</a>.
</p>

<p>
    Customizations from the original 
    <a href="https://github.com/NetCoreApps/Chat/blob/master/src/Chat/Startup.cs">.NET Core Chat implementation</a> 
    includes removing MVC and Razor dependencies and configuration, extracting its 
    <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app/_layout.html">_layout.html</a> and 
    converting <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app/index.html">index.html</a>
    to use Templates from its original 
    <a href="https://github.com/NetCoreApps/Chat/blob/master/src/Chat/wwwroot/default.cshtml">default.cshtml</a>.
    It's also been enhanced with the ability to evaluate Templates from the Chat window, as seen in the screenshot above.
</p>

<h4>Chat AppHost</h4>

{{ 'gfm/web-apps/06.md' | githubMarkdown }}

<h5>Reusing Web App's web.setting and files</h5>

<p>
    One nice thing from being able to reuse existing AppHost's is being able to develop all back-end C# Services and Custom Filters 
    as a stand-alone .NET Core Project where it's more productive with access to .NET IDE tooling and debugging.
</p>

<p>
    To account for these 2 modes we use <em>AddIfNotExists</em> to only register the <em>TemplatePagesFeature</em> plugin 
    when running as a stand-alone App and add an additional constructor so it reuses the existing <em>web.settings</em> as its 
    <a href="http://docs.servicestack.net/appsettings">IAppSettings</a> provider for is custom App configuration like OAuth App keys 
    required for enabling Sign-In's via with Twitter, Facebook and GitHub when running on <em>http://localhost:5000</em>:        
</p>

<pre class="cs"><code>debug true
name Chat Web App
port 5000
contentRoot ~/../chat
webRoot ~/../chat

oauth.RedirectUrl http://localhost:5000/
oauth.CallbackUrl http://localhost:5000/auth/{0}
oauth.twitter.ConsumerKey JvWZokH73rdghDdCFCFkJtCEU
oauth.twitter.ConsumerSecret WNeOT6YalxXDR4iWZjc4jVjFaydoDcY8jgRrGc5FVLjsVlY2Y8
oauth.facebook.Permissions email
oauth.facebook.AppId 447523305684110
oauth.facebook.AppSecret 7d8a16d5c7cbbfab4b49fd51183c93a0
oauth.github.Scopes user
oauth.github.ClientId dbe8c242e3d1099f4558
oauth.github.ClientSecret 42c8db8d0ca72a0ef202e0c197d1377670c990f4
</code></pre>

<p>
    After the back-end has been implemented we can build and copy the compiled <b>Chat.dll</b> into the Chat's 
    <a href="https://github.com/NetCoreWebApps/Chat/tree/master/app/plugins">/plugins</a> folder where 
    we can take advantage of the improved development experience for rapidly developing its UI.
</p>

{{ "doc-links" | partial({ order }) }}
