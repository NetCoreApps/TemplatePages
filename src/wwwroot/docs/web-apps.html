<!--
title: Web Apps
order: 25
-->

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp">Web Apps</a> are a new approach to dramatically simplify .NET Wep App development 
    and provide the most productive development experience possible whilst maximizing reuse and component sharing. 
    They also open up a number of new use-cases for maintaining clean isolation between front-end and back-end development with
    front-end developers not needing any knowledge of C#/.NET to be able to develop UIs for high-performance .NET Web Apps. 
    Web Apps also make it easy to establish and share an approved suite of functionality amongst multiple websites all 
    consuming the same back-end systems and data stores.
</p>

<p>
    Web Apps leverages Templates to develop entire content-rich, data-driven websites without needing to write any C#, 
    compile projects or manually refresh pages - resulting in the easiest and fastest way to develop Web Apps in .NET!
</p>

<h4>Ultimate Simplicity</h4>

<p>
    Not having to write any C# code or perform any app builds dramatically reduces the cognitive overhead and conceptual knowledge 
    required for development where the only thing front-end Web developers need to know is <a href="/docs/syntax">Template's syntax</a> 
    and what <a href="/docs/filters-reference">filters are available</a> to call. 
    Because of Template's high-fidelity with JavaScript, developing a Website with Templates will be instantly familiar to JavaScript 
    devs despite calling and binding directly to .NET APIs behind the scenes.
</p>

<p>
    All complexity with C#, .NET, namespaces, references, .dlls, strong naming, packages, MVC, Razor, build tools, IDE environments, etc 
    has been eliminated leaving all Web Developers needing to do is run a cross-platform 
    <a href="https://github.com/NetCoreWebApps/Web">web/app.dll</a> .NET Core 2.0 executable and configure a simple 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/bare/web.settings">web.settings</a>    
    text file to specify which website folder to use, which ServiceStack features to enable, which db or redis providers to connect to, etc.
    Not needing to build also greatly simplifies deployments where multiple websites can be deployed with a 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.deploy.apps.sh">single rsync</a> or xcopy command or 
    if deploying your App in a Docker Container, you just need to 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/Dockerfile">copy your website files</a>, or just the <em>web.settings</em>    
    if you're using an S3 or Azure Virtual File System.
</p>

<h4>Rapid Development Workflow</h4>

<p>
    The iterative development experience is also unparalleled for a .NET App, no compilation is required so you can just leave
    the <em>web/app.dll</em> running whilst you add the template <em>.html</em> files needed to build your App and thanks
    to the built-in <a href="/docs/hot-reloading">Hot Reloading</a> support, pages will refresh automatically as you save.
    You'll just need to do a full page refresh when modifying external .css/.js files to bypass the browser cache and
    you'll need to restart <em>web/app.dll</em> to pick up any changes to your <em>web.settings</em> or added any 
    .dlls to your <em>/plugins</em> folder.
</p>

<h2>Getting Started</h2>

<p>
    The easiest way to get started to either clone the <a href="https://github.com/NetCoreWebApps/WebAppStarter">WebAppStarter</a> GitHub project:
</p>

<pre class="cs"><code>git clone git@github.com:ServiceStack/WebAppStarter.git</code></pre>

<p>
    Or download a zip of it from <a href="https://github.com/NetCoreWebApps/WebAppStarter/archive/master.zip">github.com/ServiceStack/WebAppStarter/archive/master.zip</a>.
</p>

<p>
    This contains 2 folders, <a href="https://github.com/NetCoreWebApps/WebAppStarter/tree/master/app">/app</a> contains all source code and 
    assets for your Web App and <a href="https://github.com/NetCoreWebApps/WebAppStarter/tree/master/web">/web</a> contains a copy of the WebApp 
    binaries from <a href="https://github.com/NetCoreWebApps/Web">ServiceStack/WebApp</a>. There's also 
    <a href="https://github.com/NetCoreWebApps/WebAppStarter/blob/master/start-app.bat">start-app.bat</a> and 
    <a href="https://github.com/NetCoreWebApps/WebAppStarter/blob/master/start-app.sh">start-app.sh</a> scripts for running your app in 
    Windows, OSX and Linux. Both scripts run the same command:
</p>

<pre class="sh"><code>dotnet web/app.dll ../app/web.settings</code></pre>

<p>
    Which can be run instead of the script, it also means <em>cat start-app.bat | sh</em> will also run the app on OSX and Linux.
</p>

<p>
    Once running you can view your App on <em>http://localhost:5000/</em> which you can keep running whilst developing your app
    which will reload the page you're currently viewing on each file save using the built-in <a href="/docs/hot-reloading">Hot Reloading</a>.
</p>

<p>
    <em>/app</em> is an example of a single Web App, you can have multiple Web Apps in different folders and run any of them with:         
</p>

<pre class="sh"><code>dotnet web/app.dll ../&lt;app name&gt;/web.settings</code></pre>

<h4>Cloud Apps Starter Projects</h4>

<p>
    If you intend to deploy your Web App on AWS or Azure you may prefer to start with one of the example 
    Cloud Apps below which come pre-configured with deployment scripts for deploying with Travis CI and Docker:
</p>

<ul>
    <li><a href="https://github.com/NetCoreWebApps/Rockwind.Aws">Rockwind.Aws</a></li>
    <li><a href="https://github.com/NetCoreWebApps/Rockwind.Azure">Rockwind.Azure</a></li>
</ul>

<h2>Example Web Apps</h2>

<p>
    We've developed a number of Web Apps to illustrate the various features available and to showcase the different kind of Web Apps
    that can easily be developed. The source code for each app is maintained in
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">NetCoreWebApps/WebApp/apps</a>. Each app uses the same unmodified
    WebApp Binary that's contained in the WebAppStarter project above. 
</p>

<h4>Running Web Apps locally</h4>

<p>
    Each of these apps can be run locally by cloning <a href="https://github.com/NetCoreWebApps/WebApp">NetCoreWebApps/WebApp</a>
    and running the start.bat scripts in the <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">/apps</a> folder.
    If you want to use your local RDBMS you can use
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/northwind-data">/support/northwind-data</a> to quickly
    populate it with the Northwind database and 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/copy-files">/support/copy-files</a> to populate your own
    S3 Bucket or Azure Blob Container with the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> Web App's files. 
    As each app runs on <em>http://localhost:5000</em> you'll need to do a hard refresh with <em>Ctrl+Shift+F5</em> after
    launching each App to tell the browser to ignore the cached .css and .js from the previous App.
</p>

<h3>Bare Web App</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/bare">/bare</a> - 
    <a href="http://bare.web-app.io">bare.web-app.io</a>
</div>

<p>
    The Getting Started project contains a copy of the <a href="http://bare.web-app.io">bare.web-app.io</a> project below 
    which is representative of a typical Company splash Website:
</p>

<a href="http://bare.web-app.io"><img src="/assets/img/screenshots/bare.png" alt="Bare WebApp screenshot"></a>

<p>
    The benefits over using a static website is improved maintenance
    as you can extract and use its common <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/bare/_layout.html">_layout.html</a>
    instead of having it duplicated in each page. 
    The <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/bare/menu.html">menu.html</a> partial also makes menu items
    easier to maintain by just adding an entry in the JavaScript object literal. The dynamic menu also takes care of highlighting the active menu item.
</p>

<pre class="cs"><code>{{ 'examples/webapps-menu.html' | includeFile }}</code></pre>

<h4>Ideal for Web Designers and Content Authors</h4>

<p>
    The other primary benefit is that this is an example of a website that can be maintained by employees who don't have any
    programming experience as Templates in their basic form are intuitive and approachable to non-developers, e.g: 
    The title of each page is maintained as metadata HTML comments:
</p>

<pre class="cs"><code>&lt;!--
title: About Us
--&gt;
</code></pre>

<p>
    Template's syntax is also the ideal way to convey variable substitution, e.g: <em>&lt;title&gt;{{ pass: title }}&lt;/title&gt;</em> 
    and even embedding a partial reads like english <em>{{ pass: 'menu' | partial }}</em> which is both intuitive and works well 
    with GUI HTML designers.
</p>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/bare/web.settings">web.settings</a></h5>

<p>
    Below is the <em>web.settings</em> for a Basic App, with <b>contentRoot</b> being the only setting required as the
    rest can be inferred but including the other relevant settings is both more descriptive to other developers as well
    making it easier to 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.deploy.apps.sh">use tools like sed</a> or 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/WebApp/run.bare.ps1">powershell to replace them</a>    
    during deployment.
</p>

<pre class="settings"><code>debug true
name Bare Web App
port 5000
contentRoot ~/../bare
webRoot ~/../bare</code></pre>

<blockquote>
    <em>debug true</em> also controls the level of diagnostics available and whether or not <a href="/docs/hot-reloading">Hot Reloading</a> is enabled.
</blockquote>

<h3>Redis</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/redis">/redis</a> - 
    <a href="http://redis.web-app.io">redis.web-app.io</a>
</div>

<p>
    For the Redis Browser Web App, we wanted to implement an App that was an ideal candidate for a Single Page App but constrain ourselves
    to do all HTML rendering on the server and have each interaction request a full-page reload to see how a traditional server-generated
    Web App feels like with the performance of .NET Core 2.0 and Templates. We're pleasantly surprised with the result as when 
    the App is run locally as the responsiveness is effectively indistinguishable from an Ajax App. When hosted on the Internet 
    there is a sub-second delay which causes a noticeable flicker but it still retains a pleasant UX that's faster than most websites.
</p>

<p>
    The benefits of a traditional website is that it doesn't break the web where the back button and deep linking work without effort 
    and you get to avoid the complexity train of adopting a premier JavaScript SPA Framework's configuration, dependencies, workflow 
    and build system which has become overkill for small projects.
</p>

<a href="http://redis.web-app.io"><img src="/assets/img/screenshots/redis.png" alt="Redis WebApp Screenshot"></a>

<p>
    We've had a sordid history developing Redis UI's which we're built using the popular JavaScript frameworks that appeared 
    dominant at the time but have since seen their ecosystem decline, starting with the
    <a href="http://redisadminui.servicestack.net/">Redis Admin UI</a> (<a href="https://github.com/ServiceStackApps/RedisAdminUI">src</a>) 
    built using 
    <a href="https://github.com/google/closure-library">Google's Closure Library</a> that as it works different to everything else 
    needed a complete rewrite when creating <a href="http://redisreact.servicestack.net">redisreact.servicestack.net</a>
    (<a href="https://github.com/ServiceStackApps/RedisReact">src</a>) using the hot new React framework, unfortunately it uses React's old 
    deprecated ES5 syntax and Reflux which is sufficiently different from our current recommended 
    <a href="http://docs.servicestack.net/templates-single-page-apps">TypeScript + React + Redux + WebPack</a> JavaScript SPA Stack,
    that is going to require a significant refactor to adopt our preferred SPA tech stack.
</p>

<h5>Beautiful, succinct, declarative code</h5>

<p>
    The nice thing about generating HTML is that it's the one true constant in Web development that will always be there.
    The entire functionality for the Redis Web App is contained in a single
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/redis/index.html">/redis/index.html</a> which includes
    all Template and JavaScript Source Code in <b>&lt; 200 lines</b> which also includes all as server logic as it doesn't rely on any 
    back-end Services and just uses the <a href="/docs/redis-filters">Redis Filters</a> to interface with Redis directly.
    The <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/redis/index.html">source code</a> also serves as a good 
    demonstration of the declarative coding style that Templates encourages that in addition to being highly-readable requires orders 
    of magnitude less code than our previous Redis JavaScript SPA's with a comparable feature-set.
</p>

<p>
    Having a much smaller code-base makes it much easier to maintain and enhance whilst being less susceptible to becoming obsolete 
    by the next new JavaScript framework as it would only require rewriting 75 lines of JavaScript instead of the complete rewrite 
    that would be required to convert the existing JavaScript Apps to a use different JavaScript fx.
</p>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/redis/web.settings">web.settings</a></h5>

<p>
    The <em>web.settings</em> for Redis is similar to the Bare App except it adds a <em>redis.connection</em>
    to configure a <a href="https://github.com/ServiceStack/ServiceStack.Redis#redismanagerpool">RedisManagerPool</a> at the
    <a href="https://github.com/ServiceStack/ServiceStack.Redis#redis-connection-strings">connection string</a> provided
    as well as <a href="/docs/redis-filters">Redis Filters</a> to give Templates access to the Redis instance.
</p>

<pre class="settings"><code>debug true
name Redis Web App
port 5000
contentRoot ~/../redis
webRoot ~/../redis
redis.connection localhost:6379</code></pre>

<h3>Rockwind</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind">/rockwind</a> - 
    <a href="http://rockwind-sqlite.web-app.io">rockwind-sqlite.web-app.io</a>
</div>

<p>
    The Rockwind website shows an example of combining multiple websites in a single Web App - a 
    <b><em>Rock</em>stars</b> Content Website and a dynamic data-driven UI for the <b>North<em>wind</em></b> database which can 
    run against either SQL Server, MySql or SQLite database using just configuration. It also includes 
    <a href="/docs/api-pages">API Pages</a> examples for rapidly develop Web APIs.
</p>

<h4>Rockstars</h4>

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind/rockstars">/rockstars</a> is an 
    example of a Content Website that itself maintains multiple sub sections with their own layouts -
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind/rockstars/alive">/rockstars/alive</a> 
    for living Rockstars and 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind/rockstars/dead">/rockstars/dead</a>
    for the ones that have died. Each Rockstar maintains their own encapsulated
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind/rockstars/alive/grohl">mix of HTML, markdown content and splash image</a>
    that intuitively uses the closest <em>_layout.html</em>, <em>content.md</em> and <em>splash.jpg</em> from the page they're
    referenced from. This approach makes it easy to move entire sub sections over by just moving a folder and it will automatically
    use the relevant layout and partials of its parent.
</p>

<a href="http://rockwind-sqlite.web-app.io"><img src="/assets/img/screenshots/rockwind.png" alt="Rockwind WebApp screenshot"></a>

<h4>Northwind</h4>

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind/northwind">/northwind</a> is an example of 
    a dynamic UI for a database containing a 
    <a href="http://rockwind-sqlite.web-app.io/northwind/customers?country=Germany">form to filter results</a>, multi-nested 
    <a href="http://rockwind-sqlite.web-app.io/northwind/customer?id=ALFKI">detail pages</a> and 
    <a href="http://rockwind-sqlite.web-app.io/northwind/order?id=10643">deep-linking</a> for quickly navigating between 
    referenced data. Templates is also a great solution for rapidly developing Web APIs where the 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/api/customers.html">/api/customers.html</a>
    API Page below:
</p>

<pre class="html"><code>{{ 'examples/api-customers.txt' | includeFile }}</code></pre>

<p>
    Is all the code needed to generate the following API endpoints:
</p>

<style>
    th:first-child {
        text-align: right;
    }
</style>

<table class="table table-striped">
    <tr class="bg-success">
        <td colspan="2" style="text-align:center;color:#fff;font-size:1.5rem">/customers API</td>
    </tr>
    <tr>
        <th>All Customers</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers">/api/customers</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv">/api/customers.csv</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html">/api/customers.html</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?format=html">/api/customers?format=html</a></div>
            <div style="margin:5px 0 0 0;color:#888;font-size:13px"><b>Accept</b> HTTP Header also supported</div>
        </td>
    </tr>
    <tr>
        <th>Alfreds Futterkiste Details</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI">/api/customers/ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI.csv">/api/customers/ALFKI.csv</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers/ALFKI.html">/api/customers/ALFKI.html</a></div>
        </td>
    </tr>
    <tr>
        <th>As List</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?id=ALFKI">/api/customers?id=ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?id=ALFKI">/api/customers.csv?id=ALFKI</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?id=ALFKI">/api/customers.html?id=ALFKI</a></div>
        </td>
    </tr>
    <tr>
        <th>Customers in Germany</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?country=Germany">/api/customers?country=Germany</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?country=Germany">/api/customers.csv?country=Germany</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?country=Germany">/api/customers.html?country=Germany</a></div>
        </td>
    </tr>
    <tr>
        <th>Customers in London</th>
        <td>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers?city=London">/api/customers?city=London</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.csv?city=London">/api/customers.csv?city=London</a></div>
            <div><a href="http://rockwind-sqlite.web-app.io/api/customers.html?city=London">/api/customers.html?city=London</a></div>
        </td>
    </tr>    
    <tr>
        <th>Combination Query</th>
        <td>
            <a href="http://rockwind-sqlite.web-app.io/api/customers?city=London&amp;country=UK&amp;limit=3">/api/customers?city=London&amp;country=UK&amp;limit=3</a>
        </td>
    </tr>
</table>

<h4>Multi platform configurations</h4>

<p>
    In addition to being a .NET Core 2.0 App that runs flawlessly cross-platform on Windows, Linux and OSX, Web Apps can also support 
    multiple RDBMS's and <a href="http://docs.servicestack.net/virtual-file-system">Virtual File Systems</a> using just configuration.
</p>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.sqlite.settings">web.sqlite.settings</a></h5>

<p>
    SQLite uses a file system database letting you bundle your database with your App. So we can share the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps">northwind.sqlite</a> database across multiple Apps, 
    the <em>contentRoot</em> is set to the <em>/apps</em> directory which can only be accessed by your App, whilst
    the <em>webRoot</em> is configured to use the Web Apps folder that hosts all the publicly accessible files of your App.
</p>

<pre class="settings"><code>debug true
name Rockwind SQLite Web App
port 5000
contentRoot ~/..
webRoot ~/../rockwind
db sqlite
db.connection ~/northwind.sqlite</code></pre>

<p>
    To run the Rockwind app using the <em>northwind.sqlite</em> database, run the command below on Windows, Linux or OSX: 
</p>

<pre class="sh"><code>dotnet web/app.dll ../rockwind/web.sqlite.settings</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.sqlserver.settings">web.sqlserver.settings</a></h5>

<p>
    To switch to use the Northwind database in SQL Server we just need to update the configuration to point to a SQL Server database 
    instance. Since the App no longer need access to the <em>northwind.sqlite</em> database, the <em>contentRoot</em> can be reverted 
    back to the Web Apps folder:
</p>

<pre class="settings"><code>debug true
name Rockwind SQL Server Web App
port 5000
contentRoot ~/../rockwind
webRoot ~/../rockwind
db sqlserver
db.connection Server=localhost;Database=northwind;User Id=test;Password=test;</code></pre>

<p>
    The <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/northwind-data">/support/northwind-data</a>
    project lets you quickly try out Rockwind against your local RDBMS by populating it with a copy of the Northwind database
    using the same <em>sqlserver</em> identifier and connection string from the App, e.g:
</p>

<pre class="sh"><code>dotnet run sqlserver "Server=localhost;Database=northwind;User Id=test;Password=test;"</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.mysql.settings">web.mysql.settings</a></h5>

<p>
    You can run against a MySql database in the same way as SQL Server above but using a MySql db connection string:
</p>

<pre class="settings"><code>debug true
name Rockwind MySql Web App
port 5000
contentRoot ~/../rockwind
webRoot ~/../rockwind
db mysql
db.connection Server=localhost;Database=northwind;UID=root;Password=test</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/web.azure.settings">web.azure.settings</a></h5>

<p>
    The example Azure configuration is also configured to use a different Virtual File System where instead of sourcing 
    Web App files from the filesystem they're sourced from an 
    <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-dotnet-how-to-use-blobs">Azure Blob Container</a>.
    In this case we're not using any files from the App so we don't need to set a <em>contentRoot</em> or <em>webRoot</em> path.
    This also means that for deployment we're just deploying the <a href="https://github.com/NetCoreWebApps/Web">WebApp</a>
    binary with just this <em>web.settings</em> since both the Web App files and database are sourced remotely.
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name Azure Blob SQL Server Web App
bind *
port 5000
db sqlserver
db.connection $AZURE_SQL_CONNECTION_STRING
files azure
files.config {ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind-fs}

# Reduces a Blob Storage API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<p>
    The <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/support/copy-files">/support/copy-files</a>
    project lets you run Rockwind against your own Azure Blob Container by populating it with a copy of the 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind">/rockwind</a> App's files using 
    the same configuration above:
</p>

<pre class="sh"><code>dotnet run azure "{ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind}"</code></pre>

<h4>Multi-RDBMS SQL</h4>

<p>
    As Templates is unable to use a Typed ORM like <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a>
    to hide the nuances of each database, we need to be a bit more diligent in Templates to use parameterized SQL that works across 
    multiple databases by using the 
    <a href="/docs/filters-reference?nameContains=sql&amp;tab=db-filters"><em>sql*</em> DB Filters</a> to avoid using RDBMS-specific
    SQL syntax. The 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind/northwind/customer.html">/northwind/customer.html</a>
    contains a good example containing a number of things to watch out for:
</p>

<pre class="tpl"><code>{{ 'examples/webapps-customer-db.html' | includeFile }}</code></pre>

<p>
    Use <em>sqlConcat</em> to concatenate strings in order to return the RDBMS-specific SQL for the configured database. Likewise
    <em>sqlCurrency</em> utilizes RDBMS-specific SQL functions to return monetary values in a currency format, whilst 
    <em>sqlQuote</em> is used for quoting tables named after a reserved word.
</p>

<blockquote>
    Of course if you don't intend on supporting multiple RDBMS's, you can ignore this and use RDBMS-specific syntax.    
</blockquote>

<h3>Rockwind VFS</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> - 
    <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a>
</div>

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a> is a clone of
    the Rockwind Web App with 3 differences: It uses the <em>resolveAsset</em> filter for each <em>.js</em>, <em>.css</em> and 
    <em>image</em> web asset so that it's able to generate external URLs directly to the S3 Bucket, Azure Blob Container or CDN 
    hosting a copy of your files to both reduce the load on your Web App and maximize the responsiveness to the end user.    
</p>

<p>
    To maximize responsiveness when using remote storage, all 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/rockwind-vfs/rockstars/alive/grohl/index.html">embedded files utilize caching</a>:
</p>

<pre class="tpl"><code>{{ pass: "content.md" | includeFileWithCache | markdown }}</code></pre>

<p>
    The other difference is that each table and column has been quoted in "double-quotes" so that it works in PostgreSQL which
    otherwise treats unquoted symbols as lowercase. This version of the App also works with SQL Server and SQLite as they also 
    support <em>"Table"</em> quotes but not MySql which uses <em>`BackTicks`</em> or <em>[SquareBrackets]</em>. It's therefore
    infeasible to develop Apps that support both PostgreSQL and MySql unless you're willing to use all <b>lowercase</b>, 
    <b>snake_case</b> or the <em>sqlQuote</em> filter for every table and column.
</p>

<a href="http://rockwind-aws.web-app.io"><img src="/assets/img/screenshots/rockwind.png" alt="Rockwind VFS WebApp screenshot"></a>

<h4>resolveAsset</h4>

<p>
    If using a remote file storage like AWS S3 or Azure Blob Storage it's a good idea to use the <em>resolveAsset</em> filter 
    for each external file reference. By default it returns the same path it was called with so it will continue to work locally 
    but then ServiceStack effectively becomes a proxy where it has to call the remote Storage Service for each requested download.
</p>

<pre class="html"><code>&lt;link rel="stylesheet" href="{{ pass: 'assets/css/bootstrap.css' | resolveAsset }}" /&gt;

&lt;img src="{{ pass: 'splash.jpg' | resolveAsset }}" id="splash" alt="Dave Grohl" /&gt;</code></pre>

<p>
    ServiceStack asynchronously writes each file to the Response Stream with the last <em>Last-Modified</em> HTTP Header to 
    enable browser caching so it's still a workable solution but for optimal performance you can specify an <em>args.assetsBase</em>
    to populate the <em>assetsBase</em> TemplateContext Argument the <em>resolveAsset</em> filter uses to generate
    an external URL reference to the file on the remote storage service, reducing the load and improving the performance of your App, 
    especially if it's configured to use a CDN. 
</p>

<h4>Pure Cloud Apps</h4>

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Aws/blob/master/app/web.settings">Rockwind.Aws/web.settings</a></h5>

<p>
    The AWS settings shows an example of this where every external resource 
    <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a> has been replaced with a direct reference to the 
    asset on the S3 bucket:
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name AWS S3 PostgreSQL Web App
bind *
port 5000
db postgres
db.connection $AWS_RDS_POSTGRES
files s3
files.config {AccessKey:$AWS_ACCESS_KEY,SecretKey:$AWS_SECRET_KEY,Region:us-east-1,Bucket:rockwind}
args.assetsBase http://s3-postgresql.s3-website-us-east-1.amazonaws.com/

# Reduces an S3 API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<p>
    With all files being sourced from S3 and the App configured to use AWS RDS PostgreSQL, the AWS settings is an example of 
    a <b>Pure Cloud App</b> where the entire App is hosted on managed cloud services that's decoupled from the .NET Core 2.0 binary 
    that runs it that for the most part won't require redeploying the Web App binary unless making configuration changes or 
    upgrading the <em>web/app.dll</em> as any App changes can just be uploaded straight to S3 which changes reflected within the
    <em>checkForModifiedPagesAfterSecs</em> setting, which tells the Web App how long to wait before checking for file changes
    whilst <em>defaultFileCacheExpirySecs</em> specifies how long to cache files like <em>content.md</em> for.
</p>

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Aws/blob/master/Dockerfile">DockerFile</a></h5>

<p>
    Deployments are also greatly simplified as all that's needed is to deploy the WebApp binary and web.settings of your Cloud App,
    e.g. here's the DockerFile for <a href="http://rockwind-aws.web-app.io">rockwind-aws.web-app.io</a> - deployed to AWS ECS following our 
    <a href="http://docs.servicestack.net/deploy-netcore-docker-aws-ecs">.NET Core Docker Deployment Guidelines</a>:
</p>

<pre class="docker" style="overflow:hidden"><code>FROM microsoft/dotnet:2.0-sdk
COPY web /web
ADD https://raw.githubusercontent.com/NetCoreWebApps/Rockwind.Aws/master/app/web.settings /web/web.settings
WORKDIR /web
EXPOSE 5000/tcp
ENV ASPNETCORE_URLS https://*:5000
ENTRYPOINT ["dotnet", "/web/app.dll"]</code></pre>

<h5><a href="https://github.com/NetCoreWebApps/Rockwind.Azure/blob/master/app/web.settings">Rockwind.Azure/web.settings</a></h5>

<p>
    We can also create "Azure Cloud Apps" in the same way as AWS Cloud Apps above, which runs the same 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/rockwind-vfs">/rockwind-vfs</a>
    Web App but using an Azure hosted SQL Server database and Blob Storage:
</p>

<pre class="settings"><code># Note: values prefixed with '$' are resolved from Environment Variables
debug false
name Azure Blob SQL Server Web App
bind *
port 5000
db sqlserver
db.connection $AZURE_SQL_CONNECTION_STRING
files azure
files.config {ConnectionString:$AZURE_BLOB_CONNECTION_STRING,ContainerName:rockwind}
args.assetsBase https://servicestack.blob.core.windows.net/rockwind/

# Reduces an S3 API call, but takes longer for modified pages to appear
checkForModifiedPagesAfterSecs 60
defaultFileCacheExpirySecs     60</code></pre>

<h3>Plugins</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/plugins">/plugins</a> - 
    <a href="http://plugins.web-app.io">plugins.web-app.io</a>
</div>

<p>
    Up till now the Apps above only have only used functionality built into ServiceStack, to enable even greater functionality
    but still retain all the benefits of having a Web App you can drop <b>.dll</b> with custom functionality into your 
    Web App's <em>/plugins</em> folder. The plugins support in Web Apps is as friction-less as we could make it, there's no 
    configuration to maintain or special interfaces to implement, you're able to reuse your existing implementation <b>.dll's</b> as-is.
</p>

<p>
    Plugins allow "no touch" sharing of 
    <a href="http://docs.servicestack.net/plugins">ServiceStack Plugins</a>, 
    <a href="http://docs.servicestack.net/create-your-first-webservice">Services</a>, 
    <a href="http://templates.servicestack.net/docs/filters">Template Filters</a>
    <a href="http://templates.servicestack.net/docs/code-pages">Template Code Pages</a>,
    <a href="http://docs.servicestack.net/validation">Validators</a>, etc.
    contained within <b>.dll's</b> or <b>.exe's</b> dropped in a Web App's 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/plugins/plugins">/plugins</a> folder which are auto-registered 
    on startup. This source code for plugins used in this App were built from the .NET Core 2.0 projects in the
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/example-plugins">/example-plugins</a> folder. The 
    <a href="http://plugins.web-app.io">plugins.web-app.io</a> Web App below walks through examples of using Custom Filters, 
    Services and Validators:
</p>

<a href="http://plugins.web-app.io"><img src="/assets/img/screenshots/plugins.png" alt="Plugins WebApp screenshot"></a>

<h4>Registering ServiceStack Plugins</h4>

<p>
    <a href="http://docs.servicestack.net/plugins">ServiceStack Plugins</a> can be added to your App by 
    by listing it's Type Name in the <em>features</em> config entry in 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/plugins/web.settings">web.settings</a>:
</p>

<pre class="settings"><code>debug true
name Web App Plugins
port 5000
contentRoot ~/../plugins
webRoot ~/../plugins
features CustomPlugin, OpenApiFeature, PostmanFeature, CorsFeature, ValidationFeature
CustomPlugin { ShowProcessLinks: true }
ValidationFeature { ScanAppHostAssemblies: true }
</code></pre>

<p>
    All plugins listed in <em>features</em> will be added to your Web App's AppHost in the order they're specified. 
    They can further customized by adding a separate config entry with the Plugin Name and a JavaScript Object literal to 
    populate the Plugin at registration, e.g the config above is equivalent to:
</p>

<pre class="cs"><code>Plugins.Add(new CustomPlugin { ShowProcessLinks = true });
Plugins.Add(new OpenApiFeature());
Plugins.Add(new PostmanFeature());
Plugins.Add(new CorsFeature());
Plugins.Add(new ValidationFeature { ScanAppHostAssemblies = true });</code></pre>

<h4>Custom Plugin</h4>

<p>
    In this case it tells our <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/ServerInfo/CustomPlugin.cs">CustomPlugin</a>
    from <b>/plugins/ServerInfo.dll</b> to also show Process Links in its
    <a href="http://plugins.web-app.io/metadata">/metadata</a> Page:
</p>

<pre class="cs"><code>public class CustomPlugin : IPlugin
{
    public bool ShowDrivesLinks { get; set; } = true;
    
    public bool ShowProcessLinks { get; set; }

    public void Register(IAppHost appHost)
    {
        if (ShowDrivesLinks)
        {
            var diskFormat = Env.IsWindows ? "NTFS" : "ext2";
            appHost.GetPlugin&lt;MetadataFeature&gt;()
                .AddPluginLink("/drives", "All Disks")
                .AddPluginLink($"/drives?DriveFormatIn={diskFormat}", $"{diskFormat} Disks");
        }

        if (ShowProcessLinks)
        {
            appHost.GetPlugin&lt;MetadataFeature&gt;()
                .AddPluginLink("/processes", "All Processes")
                .AddPluginLink("/process/current", "Current Process");
        }
    }
}</code></pre>

<p>
    Where as it was first registered in the list will appear before any links registered by other plugins:
</p>

<img src="http://plugins.web-app.io/assets/img/metadata-screenshot.png" alt="Metadata screenshot">

<h4>Built-in Plugins</h4>

<p>
    It also tells the <em>ValidationFeature</em> to scan all Service Assemblies for Validators and to automatically register them
    which is how ServiceStack was able to find the
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/ServerInfo/ContactServices.cs">ContactValidator</a>
    used to validate the <em>StoreContact</em> request.
</p>

<p>
    Other optional plugins registered in this Web App is the metadata Services required for 
    <a href="http://docs.servicestack.net/openapi">Open API</a>, 
    <a href="http://docs.servicestack.net/postman">Postman</a> as well as
    <a href="http://docs.servicestack.net/corsfeature">support for CORS</a>.
    You can check the <a href="/metadata/debug">/metadata/debug</a> Template for all Plugins loaded in your AppHost.
</p>

<h3>ServiceStack Ecosystem</h3>

<p>
    All Services loaded by plugins continue to benefit from ServiceStack's rich metadata services, including being listed 
    in the <a href="/metadata">/metadata</a> page, being able to explore and interact with Services using 
    <a href="/swagger-ui/">/swagger-ui/</a> as well as being able to generate Typed APIs for the most popular
    <a href="http://docs.servicestack.net/add-servicestack-reference">Mobile, Web and Desktop platforms</a>.
</p>

<h3>Chat</h3>
<div class="source">
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/chat">/chat</a> - 
    <a href="http://chat.web-app.io">chat.web-app.io</a>
</div>

<p>
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/chat">/chat</a> is an example of the ultimate form 
    of extensibility where instead of just being able to add Services, Filters and Plugins, etc. You can add your entire 
    <em>AppHost</em> which Web Apps will use instead of its own. This vastly expands the use-cases that can be built with 
    Web Apps as it gives you complete fine-grained control over how your App is configured.
</p>

<a href="http://chat.web-app.io"><img src="/assets/img/screenshots/chat.png" alt="Chat WebApp screenshot"></a>

<h4>Develop back-end using .NET IDE's</h4>

<p>
    For <a href="http://chat.web-app.io">chat.web-app.io</a> we've taken a copy of the existing .NET Core 2.0 
    <a href="https://github.com/NetCoreApps/Chat">Chat App</a> and moved its C# code to
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/example-plugins/Chat">/example-plugins/Chat</a>
    and its files to <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/chat">/apps/chat</a> 
    where it can be developed like any other Web App except it utilizes the Chat AppHost and implementation in the 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/example-plugins/Chat/Program.cs">SelfHost Chat App</a>.
</p>

<p>
    Customizations from the original 
    <a href="https://github.com/NetCoreApps/Chat/blob/master/src/Chat/Startup.cs">.NET Core Chat implementation</a> 
    includes removing MVC and Razor dependencies and configuration, extracting its 
    <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/chat/_layout.html">_layout.html</a> and 
    converting <a href="https://github.com/NetCoreWebApps/WebApp/blob/master/src/apps/chat/index.html">index.html</a>
    to use Templates from its original 
    <a href="https://github.com/NetCoreApps/Chat/blob/master/src/Chat/wwwroot/default.cshtml">default.cshtml</a>.
    It's also been enhanced with the ability to evaluate Templates from the Chat window, as seen in the screenshot above.
</p>

<h4>Chat AppHost</h4>

<pre class="cs"><code>public class Startup
{
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        loggerFactory.AddConsole();
        var appSettings = new TextFileSettings("~/../../apps/chat/web.settings".MapProjectPath());
        app.UseServiceStack(new AppHost(appSettings));
    }
}

public class AppHost : AppHostBase
{
    public AppHost() : base("Chat Web App", typeof(ServerEventsServices).GetAssembly()) {}
    public AppHost(IAppSettings appSettings) : this() => AppSettings = appSettings;

    public override void Configure(Container container)
    {
        Plugins.AddIfNotExists(new TemplatePagesFeature()); //Already added if it's running as a Web App
        
        Plugins.Add(new ServerEventsFeature());

        SetConfig(new HostConfig
        {
            DefaultContentType = MimeTypes.Json,
            AllowSessionIdsInHttpParams = true,
        });

        this.CustomErrorHttpHandlers.Remove(HttpStatusCode.Forbidden);

        //Register all Authentication methods you want to enable for this web app.            
        Plugins.Add(new AuthFeature(
            () => new AuthUserSession(),
            new IAuthProvider[] {
                new TwitterAuthProvider(AppSettings),   //Sign-in with Twitter
                new FacebookAuthProvider(AppSettings),  //Sign-in with Facebook
                new GithubAuthProvider(AppSettings),    //Sign-in with GitHub
            }));

        container.RegisterAutoWiredAs&lt;MemoryChatHistory, IChatHistory&gt;();

        Plugins.Add(new CorsFeature(
            allowOriginWhitelist: new[] { "http://localhost", "http://null.jsbin.com" },
            allowCredentials: true,
            allowedHeaders: "Content-Type, Allow, Authorization"));
    }
}</code></pre>

<h5>Reusing Web App's web.setting and files</h5>

<p>
    One nice thing from being able to reuse existing AppHost's is being able to develop all back-end C# Services and Custom Filters 
    as a stand-alone .NET Core Project where it's more productive with access to .NET IDE tooling and debugging.
</p>

<p>
    To account for these 2 modes we use <em>AddIfNotExists</em> to only register the <em>TemplatePagesFeature</em> plugin 
    when running as a stand-alone App and add an additional constructor so it reuses the existing <em>web.settings</em> as its 
    <a href="http://docs.servicestack.net/appsettings">IAppSettings</a> provider for is custom App configuration like OAuth App keys 
    required for enabling Sign-In's via with Twitter, Facebook and GitHub when running on <em>http://localhost:5000</em>:        
</p>

<pre class="cs"><code>debug true
name Chat Web App
port 5000
contentRoot ~/../chat
webRoot ~/../chat

oauth.RedirectUrl http://localhost:5000/
oauth.CallbackUrl http://localhost:5000/auth/{0}
oauth.twitter.ConsumerKey JvWZokH73rdghDdCFCFkJtCEU
oauth.twitter.ConsumerSecret WNeOT6YalxXDR4iWZjc4jVjFaydoDcY8jgRrGc5FVLjsVlY2Y8
oauth.facebook.Permissions email
oauth.facebook.AppId 447523305684110
oauth.facebook.AppSecret 7d8a16d5c7cbbfab4b49fd51183c93a0
oauth.github.Scopes user
oauth.github.ClientId dbe8c242e3d1099f4558
oauth.github.ClientSecret 42c8db8d0ca72a0ef202e0c197d1377670c990f4
</code></pre>

<p>
    After the back-end has been implemented we can build and copy the compiled <b>Chat.dll</b> into the Chat's 
    <a href="https://github.com/NetCoreWebApps/WebApp/tree/master/src/apps/chat/plugins">/plugins</a> folder where 
    we can take advantage of the improved development experience for rapidly developing its UI.
</p>

{{ "doc-links" | partial({ order }) }}
