<!--
title: Filters
order: 6
-->

<p>
    Templates are sandboxed, they can't call methods on objects nor do they have any access to any static functions built into the .NET Framework,
    so just as Arguments define all data and objects available to templates, filters define all functionality available to templates.     
</p>

<p>
    The only filters registered by default is the 
    <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Common/Templates/TemplateDefaultFilters.cs">TemplateDefaultFilters.cs</a>
    which contains a comprehensive suite of filters useful within View Engine or Template environment. There's nothing special about the default filters
    other than they're pre-registered by default, your filters have access to the same APIs and functionality that built-in filters do. 
</p>

<p>
    If you want to start from a clean slate, the default filters can be removed by clearing the <em>TemplateFilters</em> collection:
</p>

<pre><code>context.TemplateFilters.Clear();</code></pre>

<h4>What are Filters?</h4>

<p>
    Filters are just C# public instance methods from a class that inherits from <em>TemplateFilter</em>, e.g:
</p>

<pre class="cs"><code>class MyFilter : TemplateFilter
{
    public string echo(string text) => $"{text} {text}";
    public double squared(double value) => value * value;
    public string greetArg(string key) => $"Hello {Context.Args[key]}";
            
    public ICacheClient Cache { get; set; }
    public string fromCache(string key) => Cache.Get<string>(key);
}
</code></pre>

<h4 id="registering-filters">Registering Filters</h4>

<p>
    The examples below show the number of different ways filters can be registered:
</p>

<h5>Add them to the TemplateContext.TemplateFilters</h5>

<p>
    Filters can be registered by adding them to the <em>context.TemplateFilters</em> collection directly:
</p>

<pre class="cs"><code>var context = new TemplateContext
{
    Args =
    {
        ["contextArg"] = "foo"
    },
    TemplateFilters = { new MyFilter() }
}.Init();
</code></pre>

<p>That can now be called with:</p>

<pre class="cs"><code>var output = context.EvaluateTemplate("&lt;p&gt;{{ pass: 'contextArg' | greetArg }}&lt;/p&gt;");</code></pre>

<p>
    This is also shows that Filters are initialized and have access to the <em>TemplateContext</em> through the <em>Context</em> property.
</p>

<h5>Add them to PageResult.TemplateFilters</h5>

<p>
    If you only want to use a custom filter in a single Template, it can be registered on the <em>PageResult</em> that renders it instead:
</p>

<pre class="cs"><code>var output = new PageResult(context.OneTimePage("&lt;p&gt;{{ pass: 'hello' | echo }}&lt;/p&gt;"))
{
    TemplateFilters = { new MyFilter() }
}.Result;
</code></pre>

<h5>Autowired using TemplateContext IOC</h5>

<p>
    Autowired instances of filters can also be created using TemplateContext's configured IOC where they're 
    also injected with any registered IOC dependencies. To utilize this you need to specify the Type of the filter that 
    should be Autowired by either adding it to the <em>ScanTypes</em> collection:
</p>

<pre class="cs"><code>var context = new TemplateContext
{
    ScanTypes = { typeof(MyFilter) }
};
context.Container.AddSingleton<ICacheClient>(() => new MemoryCacheClient());
context.Container.Resolve<ICacheClient>().Set("key", "foo");
context.Init();

var output = context.EvaluateTemplate("&lt;p&gt;{{ pass: 'key' | fromCache }}&lt;/p&gt;");
</code></pre>

<p>
    When the <em>TemplateContext</em> is initialized it will go through each Type and create an autowired instance of each Type
    and register them in the <em>TemplateFilters</em> collection. An alternative to registering a single Type is to register 
    an entire Assembly, e.g:
</p>

<pre class="cs"><code>var context = new TemplateContext
{
    ScanAssemblies = { typeof(MyFilter).GetAssembly() }
};
</code></pre>

<p>
    Where it will search each Type in the Assembly for Template Filters and automatically register them.
</p>

<h4>Auto coercion into Filter argument Types</h4>

<p>
    A unique feature of Filters is that each of their arguments are automatically co-erced into the filter argument Type using the 
    powerful conversion facilities built into ServiceStack's 
    <a href="http://docs.servicestack.net/auto-mapping">Auto Mapping Utils</a> and 
    <a href="https://github.com/ServiceStack/ServiceStack.Text">Text Serializers</a> which can deserialize most of .NET's primitive Types like 
    <em>DateTime</em>, <em>TimeSpan</em>, <em>Enums</em>, etc in/out of strings as well being able to convert a Collection into other Collection 
    Types and any Numeric Type into any other Numeric Type which is how, despite only accepting doubles: 
</p>

<pre class="cs"><code>double squared(double value) => value * value;</code></pre>

<p>
    Can also be used with any other .NET Numeric Type, e.g: <em>byte</em>, <em>int</em>, <em>long</em>, <em>decimal</em>, etc.
    The consequence to this is that there's no method overloading in filters, filters are matched based on their name and their number of arguments
    and each argument is converted into its filter method Param Type before it's called.
</p>

<h4>Context Filters</h4>

<p>
    Filters can also get access to the current scope by defining a <em>TemplateScopeContext</em> as it's first parameter which 
    can be used to access arguments in the current scope or add new ones as done by the <em>assignTo</em> filter:
</p>

<pre class="cs"><code>public object assignTo(TemplateScopeContext scope, object value, string argName) //from filter
{
    scope.ScopedParams[argName] = value;
    return IgnoreResult.Value;
}
</code></pre>

<h4 id="block-filters">Block Filters</h4>

<p>
    Filters can also write directly into the OutputStream instead of being forced to return buffered output. A Block Filter
    is declared by its <em>Task</em> return Type where instead of returning a value it instead writes directly to the 
    <em>TemplateScopeContext</em> OutputStream as seem with the implementation of the <em>includeFile</em> protected filter:
</p>

<pre class="cs"><code>public async Task includeFile(TemplateScopeContext scope, string virtualPath)
{
    var file = scope.Context.VirtualFiles.GetFile(virtualPath);
    if (file == null)
        throw new FileNotFoundException($"includeFile '{virtualPath}' was not found");

    using (var reader = file.OpenRead())
    {
        await reader.CopyToAsync(scope.OutputStream);
    }
}
</code></pre>

<blockquote>
    For maximum performance all default filters which perform any I/O use Block filters to write directly to the OutputStream 
    and avoid any blocking I/O or buffering. 
</blockquote>

<h4>Block Filters ends the filter chain</h4>

<p>
    Block filters effectively end the Filter chain expression since they don't return any value that can be injected into 
    a normal filter. The only thing that can come after a Block Filter are other Block Filters or Filter Transformers. 
    If any are defined, the output of the Block Filter is buffered into a <em>MemoryStream</em> and passed into
    the next Block Filter or Filter Transformer in the chain, its output is then passed into the next one in the chain if any, 
    otherwise the last output is written to the OutputStream.
</p>

<p>
    An example of using a Block filter with a Filter Transformer is when you want include a markdown document and then 
    convert it to HTML using the <b>markdown</b> Filter Transformer before writing its HTML output to the OutputStream:
</p>

<pre class="cs"><code>{{ pass: 'doc.md' | includeFile | markdown }}</code></pre>

<h4>Capture Block Filter Output</h4>

<p>
    You can also capture the output of a Block Filter and assign it to a normal argument by using the <em>assignTo</em> Block Filter:
</p>

<pre class="cs"><code>{{ pass: 'doc.md' | includeFile | assignTo: contents }}</code></pre>

{{ "doc-links" | partial({ order }) }}
